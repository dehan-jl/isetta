package dnsconfig

import (
	"fmt"
	"net"
	"os"
	"regexp"

	"gopkg.in/ini.v1"
	"org.samba/isetta/helper"
	log "org.samba/isetta/simplelogger"
)

const ResolvConfPath = "/etc/resolv.conf"
const WslConfPath = "/etc/wsl.conf"

type DnsConfigurerImpl struct {}


func (DnsConfigurerImpl) ActivateDnsServer(dnsServerip string) {
	if !isDnsServerSet(dnsServerip, ResolvConfPath) {
		setServer(ResolvConfPath, dnsServerip)
	}
}

func isDnsServerSet(address string, resolvConfPath string) bool {
	content, err := readResolveConf(resolvConfPath)
	helper.AssertNoError2(err)

	// multiline match mode
	// matches e.g. "nameserver 8.8.8.8"
	regex := fmt.Sprintf("(?m:^nameserver[[:space:]]+%v[[:space:]]*$)", address)
	matched, err := regexp.MatchString(regex, content)
	helper.AssertNoError(err, "unable to access file %v.", ResolvConfPath)

	if matched {
		log.Logger.Debug("DNS server %v already set in %v", address, resolvConfPath)
		return true
	} else {
		log.Logger.Debug("DNS server %v is not set in %v", address, resolvConfPath)
		return false
	}
}

func readResolveConf(resolvConfPath string) (string, error) {
	content, err := os.ReadFile(resolvConfPath)
	if err != nil {
		return "", fmt.Errorf("unable to read file %v, Error was: %w", resolvConfPath, err)
	}
	return string(content), nil
}

func setServer(path string, ip string) {
	err := isIpValid(ip)
	helper.AssertNoError2(err)

	f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	helper.AssertNoError(err, "error accessing file %v", f)
	defer f.Close()

	log.Logger.Debug("Setting DNS server %v in %v", ip, path)
	f.WriteString(fmt.Sprintf("# generated by isetta\nnameserver %v\n", ip))
}

func isIpValid(ip string) error {
	if net.ParseIP(ip) == nil {
		return fmt.Errorf("DNS server IP address '%v' is invalid", ip)
	} else {
		return nil
	}
}

func (DnsConfigurerImpl) DisableResolveAutoConfGeneration() {
	log.Logger.Debug("Ensuring auto-generation of %v in %v is disabled", ResolvConfPath, WslConfPath)
	disableResolvConfGenerationForFile(WslConfPath)
}

func disableResolvConfGenerationForFile(path string) {
	createIfNotExists(path)

	cfg, err := ini.Load(path)
	helper.AssertNoError(err, "fail to load file: %v", path)
	
	setToFalse(cfg, path)
	err = cfg.SaveTo(path)
	helper.AssertNoError(err, "fail to save file: %v", path)
}

func createIfNotExists(path string) {
	f, err := os.OpenFile(path, os.O_CREATE, 0644)
	helper.AssertNoError(err, "error accessing file: %v", path)
	f.Close()
}

func setToFalse(cfg *ini.File, path string) {
	key := cfg.Section("network").Key("generateResolvConf")

	generateResolvConf, err := key.Bool()
	if generateResolvConf || err != nil {
		log.Logger.Debug("Disabling auto-generation of %v in %v", ResolvConfPath, WslConfPath)
		log.Logger.Trace("In %v key 'generateResolvConf' was 'true' or not set. Setting it to 'false'", WslConfPath)
		key.SetValue("false")
	} else {
		log.Logger.Trace("Auto-generation of %v already disabled. Nothing to do", ResolvConfPath)
	}

	// post-condition
	generateResolvConf, err = key.Bool()
	if generateResolvConf || err != nil {
		log.Logger.Error("Failed to change 'generateResolvConf' in %v", path)
	}
}
